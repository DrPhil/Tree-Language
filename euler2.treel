triage leaf stem branch = t (t leaf stem) branch
let x f = f x

# SKI combinators
id x = x
K = t t
S = t (t (t t t)) t
I = t (t (t t)) t
U = t (t id) id
B = S (K S) K
C = S (B B S) (K K)
W = S S (K S)
Y = B U (C B U)

fst l r = l
snd l r = r

# Bools
true = t
false = t t
if b tt ff = triage tt (fst ff) t b
not b = if b false true
or a b = if a true b
and a b = if a b false
and3 a b c = and (and a b) c
xor2 a b = if a (not b) b
xor3 a b c = xor2 (xor2 a b) c
majority a b c = if a (or b c) (and b c)

# Lists
nil = t
cons e list = t e list

head list = triage false t fst list
tail list = triage nil t snd list
isEmpty list = triage true t (\a \b false) list

filter f list = if (isEmpty list) nil $
  let (filter f (tail list)) \rest
  if (f (head list))
    (cons (head list) rest)
    rest

takeWhile f list = if (isEmpty list) nil $
  if (f (head list))
    (cons (head list) (takeWhile f (tail list)))
    nil

# Numbers
# numbers are lists of bools. Least significant bit is at the top of the tree.

isEven n = or (isEmpty n) (not (head n))

# n <= m 
# 1nnn
# 0mmm

lte n m = if (and (isEmpty n) (isEmpty m)) true $
  if (and (head n) (not (head m)))
    (not (lte (tail m) (tail n)))
    (lte (tail n) (tail m))

0b n = cons false n
1b n = cons true n

_add carry n m = 
  let (and3 (not carry) (isEmpty n) (isEmpty m)) \done
  let (xor3 carry (head n) (head m)) \bit
  let (majority carry (head n) (head m)) \newCarry
  if (done)
    nil
    (cons bit (_add newCarry (tail n) (tail m)))
    
add = _add false

0 = nil
1 = cons true nil
2 = cons false (cons true nil)
3 = cons true (cons true nil)
4 = add 2 2
8 = add 4 4
16 = add 8 8

4_000_000 = 0b $ 0b $ 0b $ 0b $ 0b $ 0b $ 0b $ 0b $
            1b $ 0b $ 0b $ 1b $ 0b $ 0b $ 0b $ 0b $
            1b $ 0b $ 1b $ 1b $ 1b $ 1b nil

_fib a b = cons b (_fib b (add a b))
fib = _fib 1 1

# Euler 2
evenfibs = filter isEven fib
firstEvenFibs = takeWhile (\n lte n 4_000_000) evenfibs

sum list = if (isEmpty list) 0 (add (head list) (sum (tail list)))

result = sum firstEvenFibs
