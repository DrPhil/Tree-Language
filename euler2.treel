triage leaf stem branch = t (t leaf stem) branch
let x f = f x

# SKI combinators
id x = x
K = t t
S = t (t (t t t)) t
I = t (t (t t)) t
U = t (t id) id
B = S (K S) K
C = S (B B S) (K K)
W = S S (K S)
Y = B U (C B U)

fst l r = l
snd l r = r

# Bools
true = t
false = t t
if b tt ff = triage tt (fst ff) t b
not b = if b false true
or a b = if a true b
and a b = if a b false
and3 a b c = and (and a b) c
xor2 a b = if a (not b) b
xor3 a b c = xor2 (xor2 a b) c
majority a b c = if a (or b c) (and b c)

# Lists
nil = t
cons e list = t e list

head list = triage false t fst list
tail list = triage nil t snd list
isEmpty list = triage true t (\a \b false) list

filter f list = if (isEmpty list) nil $
  let (filter f (tail list)) \rest
  if (f (head list))
    (cons (head list) rest)
    rest

takeWhile f list = if (isEmpty list) nil $
  if (f (head list))
    (cons (head list) (takeWhile f (tail list)))
    nil

# Numbers
# numbers are lists of bools. Least significant bit is at the top of the tree.

isEven n = or (isEmpty n) (not (head n))

# n <= m 
# 1nnn
# 0mmm

lte n m = if (and (isEmpty n) (isEmpty m)) true $
  if (and (head n) (not (head m)))
    (not (lte (tail m) (tail n)))
    (lte (tail n) (tail m))


_add carry n m = 
  let (and3 (not carry) (isEmpty n) (isEmpty m)) \done
  let (xor3 carry (head n) (head m)) \bit
  let (majority carry (head n) (head m)) \newCarry
  if (done)
    nil
    (cons bit (_add newCarry (tail n) (tail m)))
    

add = _add false

_fib a b = cons b (_fib b (add a b))
fib = _fib 1 1

# Euler 2
evenfibs = filter isEven fib
firstEvenFibs = takeWhile (\n lte n 4_000_000) evenfibs
sum list = if (isEmpty list) 0 (add (head list) (sum (tail list)))

result = sum firstEvenFibs


mul n m = if (not (isEmpty n)) 
    (add (if (head n) m nil) (cons false (mul (tail n) m))) 
    nil

sub1 n = if (head n) 
    (cons false (tail n)) 
    (cons true (sub1 (tail n)))


sub n m = if (isEmpty m) 
    n 
    $ let (sub (tail n) (tail m)) \subtree
    if (xor2 (head m) (head n)) 
        (cons true (
            if (head n) 
                subtree
                (sub1 subtree)))
        (cons false subtree)